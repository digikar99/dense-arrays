(cl:in-package :dense-arrays)

(defmacro with-speed-optimization ((env form) &body body)
  `(if (= 3 (env:policy-quality 'speed ,env))
       (let ((s *error-output*))
         (flet ((optim-failure ()
                  (terpri s)
                  (pprint-logical-block (s nil :per-line-prefix "; ")
                    (format s "Unable to portably optimize~%")
                    (pprint-logical-block (s nil :per-line-prefix "  ")
                      (format s "~S" form))
                    (format s "~%because:~%")
                    (pprint-logical-block (s nil :per-line-prefix "  ")
                      (format s "Can only optimize when ARRAY is a symbol~%or a list of the form (THE TYPE FORM)"))
                    (format s "~&but is:~%")
                    (pprint-logical-block (s nil :per-line-prefix "  ")
                      (format s "~S" array))))
                (unknown-backend (backend)
                  (pprint-logical-block (s nil :per-line-prefix "; ")
                    (format s "Unable to portably optimize")
                    (pprint-logical-block (s nil :per-line-prefix "  ")
                      (format s "~S" form))
                    (format s "because backend ~S is not known" backend)))
                (insufficient-declarations (reason &rest reason-args)
                  (terpri s)
                  (pprint-logical-block (s nil :per-line-prefix "; ")
                    (format s "Unable to portably optimize~%")
                    (pprint-logical-block (s nil :per-line-prefix "  ")
                      (format s "~S" form))
                    (format s "~%because:~%")
                    (pprint-logical-block (s nil :per-line-prefix "  ")
                      (apply #'format s reason reason-args)))))
           (declare (ignorable (function optim-failure)
                               (function unknown-backend)
                               (function insufficient-declarations)))
           ,@body))
       ,form))

(defun dense-array-type-backend (array-type &optional env) ; backend-name
  (let ((array-type (introspect-environment:typexpand array-type env)))
    (assert (and (subtypep array-type 'dense-array)
                 (eq 'and (first array-type)))
            ()
            "Expected ARRAY-TYPE to be of the form (AND DENSE-ARRAY ...) but is~%  ~S"
            array-type)
    (loop :for clause :in (intersection-type-types array-type)
          :if (and (listp clause)
                   (eq 'satisfies (first clause)))
            :do (let* ((fn-name (symbol-name (second clause)))
                       (prefix  "DENSE-ARRAY-BACKEND-")
                       (elt-pos (search prefix fn-name))
                       (start-pos (length prefix))
                       (end-pos (search "-P" fn-name)))
                  (when (and elt-pos end-pos)
                    (return-from dense-array-type-backend
                      (let ((*read-eval* nil))
                        (read-from-string (subseq fn-name start-pos end-pos)))))))
    'cl:*))

;;; TODO: Integrate with form-type of adhoc-polymorphic-functions (?)
;;; Or, make a trivial-form-type package
(defun compile-time-array-type (array &optional env)
  (let ((array-type
          (introspect-environment:typexpand
           (cond ((symbolp array)
                  (cdr (when-let (type-information
                                  (assoc 'type
                                         (nth-value 2
                                                    (env:variable-information array env))))
                         type-information)))
                 ((and (listp array) (eq 'the (first array)))
                  (second array))
                 (t (return-from compile-time-array-type nil))))))
    (if (and (listp array-type)
             (eq 'and (first array-type)))
        (values (dense-array-type-backend array-type env)
                (array-type-element-type array-type env)
                (array-type-rank array-type env)
                (subtypep array-type 'simple-dense-array))
        (values 'cl:* 'cl:* 'cl:* nil))))
